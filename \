use crate::CONF;
use jsonwebtoken::{self as jwt, TokenData};
use rocket::http::Status;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

lazy_static! {
    // set secret for encoding json web token
    static ref JWTKENCODE: jwt::EncodingKey = jwt::EncodingKey::from_secret(CONF.jwt.secret.as_ref());
    static ref JWTKDECODE: jwt::DecodingKey = jwt::DecodingKey::from_secret(CONF.jwt.secret.as_ref());
}

/**
 * scopes that define what a client is allowed to do
 */
#[derive(Deserialize, Serialize, PartialEq, Eq, Hash)]
pub enum Scope {
    Read,
    Write,
}

#[derive(Deserialize, Serialize)]
pub struct Claims {
    pub userid: String,
    pub scopes: Vec<Scope>,
}

/**
data used to log a user in with password and userid
**/
#[derive(Deserialize, Serialize, PartialEq, Eq, Hash)]
pub struct UserAuthData {
    pub userid: String,
    pub pass: String,
}

/**
 * used to define scopes when authenticating a client
 */
#[derive(Deserialize, Serialize)]
pub struct ClientAuthData {
    scopes: Vec<Scope>,
    user: UserAuthData,
}

/// get set of valid users
fn get_valid_users() -> HashSet<UserAuthData> {
    //TODO do not just authenticate zork
    let zork = UserAuthData {
        userid: "zork".to_string(),
        pass: "zorkrules".to_string(),
    };
    HashSet::from([zork])
}

#[derive(Deserialize, Serialize)]
pub struct Key {
    key: String,
}

/**
*initial authentication with username and password
*TODO returns encoded token if credentials are true
*/
pub async fn authenticate_user(data: ClientAuthData) -> Result<String, (Status, String)> {
    if !get_valid_users().contains(&data.user) {
        return Err((
            Status::Unauthorized,
            "failed to authenticate user with these credentials".to_string(),
        ));
    }
    jwt::encode(
        &jwt::Header::default(),
        &Claims {
            userid: data.user.userid,
            scopes: data.scopes,
        },
        &JWTKENCODE,
    )
    .map_err(|e| (Status::InternalServerError, e.to_string()))
}

/**
TODO
authentication with webtoken
**/
pub fn authenticate_token(token: &String) -> Result<Claims>, (Status, String)> {
    jwt::decode::<Claims>(token, &JWTKDECODE, &jwt::Validation::default())
        .map_err(|e| (Status::Unauthorized, e.to_string()))
}
